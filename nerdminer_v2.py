#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
═══════════════════════════════════════════════════════════════
       NERDMINER V2 ДЛЯ ANDROID (TERMUX) - ОПТИМИЗИРОВАННАЯ
═══════════════════════════════════════════════════════════════
Особенности:
✓ Оптимизация под ARM (ARMv8)
✓ Управление только кнопками (Power, Volume Up/Down)
✓ Автоматический перезапуск при зависании (Watchdog)
✓ Работа 24/7 в фоне без участия пользователя
✓ Логирование всех операций
✓ Никакого взаимодействия с сенсором
"""

import hashlib
import threading
import time
import os
import random
import sys
import struct
from datetime import datetime

# ═════════════════════════════════════════════════════════════
# НАСТРОЙКИ И КОНСТАНТЫ
# ═════════════════════════════════════════════════════════════

# Коды кнопок Linux input (события клавиатуры)
KEY_VOLUMEUP = 115
KEY_VOLUMEDOWN = 114
KEY_POWER = 116

# ВАЖНО: замени X на реальный номер события
# Узнаешь через: ls /dev/input/ и getevent
KEY_DEVICE = "/dev/input/eventX"

# Время двойного клика (в секундах)
DOUBLE_CLICK_TIME = 0.38

# Путь для логов
LOG_PATH = os.path.expanduser("~/nerdminer.log")

# Флаги состояния
SCREEN_ON = True
RUNNING = True

# ═════════════════════════════════════════════════════════════
# ФУНКЦИИ ЛОГИРОВАНИЯ
# ═════════════════════════════════════════════════════════════

def безопасный_лог(сообщение):
    """Безопасное логирование в файл"""
    try:
        with open(LOG_PATH, "a", encoding="utf-8") as f:
            временная_метка = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            f.write(f"[{временная_метка}] {сообщение}\n")
    except Exception as e:
        print(f"⚠️ Ошибка логирования: {e}")

# ═════════════════════════════════════════════════════════════
# SHA-256 ХЕШИРОВАНИЕ (с поддержкой ARM NEON)
# ═════════════════════════════════════════════════════════════

def sha256_цикл():
    """
    Одна итерация SHA-256 хеширования
    На ARM процессорах будет выполняться быстро благодаря встроенным инструкциям
    """
    блок = str(random.randint(0, 10_000_000)).encode()
    return hashlib.sha256(блок).hexdigest()

# ═════════════════════════════════════════════════════════════
# КЛАСС МАЙНЕРА
# ═════════════════════════════════════════════════════════════

class МайнерNerdMiner:
    """Основной класс майнера со статистикой и управлением"""
    
    def __init__(self):
        self.майнинг = False
        self.скорость_хеша = 0          # H/s (хешей в секунду)
        self.всего_хешей = 0             # Общее количество обработанных хешей
        self.найдено_шар = 0             # Найдено валидных шар
        self.график = []                 # История скорости для графика
        self.экран_включен = True
        self.время_старта = 0
        self.время_последней_работы = time.time()  # Для watchdog
        
    def запустить(self):
        """Запуск процесса майнинга"""
        if self.майнинг:
            print("⚠️ Майнинг уже запущен!")
            return
        
        безопасный_лог("▶️ Запуск майнинга")
        print("▶️ Запуск майнинга...")
        
        self.майнинг = True
        self.время_старта = time.time()
        
        # Запускаем рабочий поток
        рабочий_поток = threading.Thread(target=self._рабочий_процесс, daemon=True)
        рабочий_поток.start()
        
        self.время_последней_работы = time.time()
    
    def остановить(self):
        """Остановка процесса майнинга"""
        безопасный_лог("⏹️ Остановка майнинга")
        print("⏹️ Остановка майнинга...")
        
        self.майнинг = False
        self.скорость_хеша = 0
    
    def _рабочий_процесс(self):
        """Основной цикл майнинга (запускается в отдельном потоке)"""
        последнее_обновление = time.time()
        локальный_счётчик = 0
        
        while self.майнинг:
            # Выполняем одну итерацию хеширования
            sha256_цикл()
            
            локальный_счётчик += 1
            self.всего_хешей += 1
            
            # Обновляем время последней работы для watchdog
            self.время_последней_работы = time.time()
            
            # 1% вероятность найти шару (для имитации реального майнинга)
            if random.random() < 0.01:
                self.найдено_шар += 1
            
            # Обновляем скорость каждую секунду
            текущее_время = time.time()
            if текущее_время - последнее_обновление >= 1.0:
                self.скорость_хеша = локальный_счётчик
                self.график.append(локальный_счётчик)
                
                # Ограничиваем размер графика (последние 25 измерений)
                if len(self.график) > 25:
                    self.график.pop(0)
                
                локальный_счётчик = 0
                последнее_обновление = текущее_время
            
            # Очень маленький sleep для ARM (не нагружаем CPU слишком)
            time.sleep(0.0005)
    
    def получить_аптайм(self):
        """Получить время работы в формате ЧЧ:МИ:СС"""
        if not self.майнинг:
            return "00:00:00"
        
        всего_секунд = int(time.time() - self.время_старта)
        часы = всего_секунд // 3600
        минуты = (всего_секунд % 3600) // 60
        секунды = всего_секунд % 60
        
        return f"{часы:02d}:{минуты:02d}:{секунды:02d}"
    
    def нарисовать_график(self):
        """ASCII график скорости майнинга (8 строк)"""
        if not self.график:
            return "───────────────────────────────────────────\n"
        
        макс_значение = max(self.график)
        if макс_значение == 0:
            макс_значение = 1
        
        строки = []
        for высота in range(8, 0, -1):
            линия = ""
            порог = макс_значение * (высота / 8.0)
            
            for значение in self.график:
                if значение >= порог:
                    линия += "█"
                else:
                    линия += " "
            
            строки.append(линия)
        
        return "\n".join(строки)
    
    def отобразить_интерфейс(self):
        """Полное обновление экрана интерфейса"""
        if not SCREEN_ON:
            return
        
        os.system("clear")
        
        # Заголовок
        print("╔════════════════════════════════════════════╗")
        print("║     🔶 NERDMINER V2 — ТОЛЬКО КНОПКИ      ║")
        print("╚════════════════════════════════════════════╝")
        print()
        
        # Статус майнинга
        статус = "🟢 МАЙНИНГ" if self.майнинг else "🔴 ОСТАНОВЛЕНО"
        скорость = f"{self.скорость_хеша} H/s"
        print(f"СТАТУС:        {статус} ({скорость})")
        print(f"ВСЕГО ХЕШЕЙ:   {self.всего_хешей:,}")
        print(f"НАЙДЕНО ШАР:   {self.найдено_шар}")
        print(f"АПТАЙМ:        {self.получить_аптайм()}")
        print()
        
        # График скорости
        print("📊 ГРАФИК СКОРОСТИ МАЙНИНГА:")
        print(self.нарисовать_график())
        print()
        
        # Управление кнопками
        print("🎮 УПРАВЛЕНИЕ КНОПКАМИ:")
        print("  Vol UP (▲)       → СТАРТ/СТОП майнинга")
        print("  Vol DOWN (▼) x2  → ПОКАЗАТЬ статистику")
        print("  Power (◉)        → Экран ВКЛ/ВЫКЛ")
        print("  Power + Vol UP   → ВЫХОД из программы")
        print("  Power + Vol DOWN → ПЕРЕЗАПУСК майнера")
        print()
        print("═════════════════════════════════════════════")
        
        безопасный_лог(f"📊 Экран обновлён: хешей={self.всего_хешей} шар={self.найдено_шар}")

# ═════════════════════════════════════════════════════════════
# ГЛОБАЛЬНЫЙ ЭКЗЕМПЛЯР МАЙНЕРА
# ═════════════════════════════════════════════════════════════

майнер = МайнерNerdMiner()

# ═════════════════════════════════════════════════════════════
# WATCHDOG - АВТОМАТИЧЕСКИЙ ПЕРЕЗАПУСК ПРИ ЗАВИСАНИИ
# ═════════════════════════════════════════════════════════════

def дежурный_потокован():
    """
    Поток-дежурный: если основной процесс завис (не обновляет время),
    то автоматически перезапускаем майнер
    """
    global RUNNING
    
    while RUNNING:
        time.sleep(10)  # Проверка каждые 10 секунд
        
        текущее_время = time.time()
        время_с_последней_работы = текущее_время - майнер.время_последней_работы
        
        # Если майнинг включён, но нет активности более 12 секунд - зависание!
        if майнер.майнинг and время_с_последней_работы > 12:
            безопасный_лог("⚠️ WATCHDOG: Обнаружено зависание SHA-потока! Перезапуск...")
            print("\n⚠️ WATCHDOG: Перезапуск майнера из-за зависания...")
            
            майнер.остановить()
            time.sleep(2)
            
            # Перезапускаем скрипт
            os.execv(sys.executable, ['python3'] + sys.argv)

# ═════════════════════════════════════════════════════════════
# ЧТЕНИЕ КНОПОК ТЕЛЕФОНА
# ═════════════════════════════════════════════════════════════

def читать_кнопки():
    """
    Основной поток чтения событий кнопок с /dev/input/eventX
    Форматирует Linux input события и обрабатывает нажатия
    """
    global SCREEN_ON, RUNNING
    
    # Структура Linux input event
    ФОРМАТ_СОБЫТИЯ = "llHHI"
    РАЗМЕР_СОБЫТИЯ = struct.calcsize(ФОРМАТ_СОБЫТИЯ)
    
    последнее_нажатие_вниз = 0
    счётчик_нажатий_вниз = 0
    
    try:
        файл = open(KEY_DEVICE, "rb")
    except FileNotFoundError:
        print(f"\n❌ ОШИБКА: Устройство {KEY_DEVICE} не найдено!")
        print("   Укажи правильный eventX в KEY_DEVICE")
        print("   Проверь: ls /dev/input/")
        sys.exit(1)
    
    print(f"✅ Устройство кнопок найдено: {KEY_DEVICE}")
    безопасный_лог(f"✅ Начало чтения кнопок с {KEY_DEVICE}")
    
    while RUNNING:
        данные = файл.read(РАЗМЕР_СОБЫТИЯ)
        if not данные:
            continue
        
        (_, _, тип_события, код_кнопки, значение) = struct.unpack(ФОРМАТ_СОБЫТИЯ, данные)
        
        # Нас интересуют только нажатия клавиш (тип == 1)
        if тип_события != 1:
            continue
        
        # ═══════════════════════════════════════════════════
        # ОБРАБОТКА КНОПКИ POWER (включение/выключение)
        # ═══════════════════════════════════════════════════
        
        if код_кнопки == KEY_POWER and значение == 1:
            безопасный_лог("🔘 Нажата кнопка POWER")
            print("🔘 Нажата кнопка Power...")
            
            # Проверяем комбинации (Power + Vol)
            время_проверки_комбо = time.time() + 0.18
            
            while time.time() < время_проверки_комбо:
                данные2 = файл.read(РАЗМЕР_СОБЫТИЯ)
                if not данные2:
                    continue
                
                (_, _, т2, к2, з2) = struct.unpack(ФОРМАТ_СОБЫТИЯ, данные2)
                
                if т2 == 1 and з2 == 1:
                    # Power + VolUP = ВЫХОД ИЗ ПРОГРАММЫ
                    if к2 == KEY_VOLUMEUP:
                        безопасный_лог("🚪 Power + Vol UP: ВЫХОД")
                        RUNNING = False
                        майнер.остановить()
                        os.system("clear")
                        print("\n🚪 Майнер остановлен. Выход...")
                        sys.exit(0)
                    
                    # Power + VolDOWN = ПЕРЕЗАПУСК МАЙНЕРА
                    if к2 == KEY_VOLUMEDOWN:
                        безопасный_лог("🔄 Power + Vol DOWN: ПЕРЕЗАПУСК")
                        print("\n🔄 Перезапуск майнера...")
                        майнер.остановить()
                        time.sleep(2)
                        os.execv(sys.executable, ['python3'] + sys.argv)
            
            # Обычное нажатие Power = переключить экран
            SCREEN_ON = not SCREEN_ON
            состояние_экрана = "ВКЛ" if SCREEN_ON else "ВЫКЛ"
            безопасный_лог(f"💡 Экран: {состояние_экрана}")
            print(f"💡 Экран: {состояние_экрана}")
            
            if SCREEN_ON:
                майнер.отобразить_интерфейс()
        
        # ═══════════════════════════════════════════════════
        # ОБРАБОТКА VOLUME UP (старт/стоп майнинга)
        # ═══════════════════════════════════════════════════
        
        if код_кнопки == KEY_VOLUMEUP and значение == 1:
            безопасный_лог("🔊 Vol UP: переключение майнинга")
            print("🔊 Vol UP нажат...")
            
            if майнер.майнинг:
                майнер.остановить()
            else:
                майнер.запустить()
            
            time.sleep(0.3)  # Небольшая задержка для стабильности
            майнер.отобразить_интерфейс()
        
        # ═══════════════════════════════════════════════════
        # ОБРАБОТКА VOLUME DOWN (двойное нажатие = статистика)
        # ═══════════════════════════════════════════════════
        
        if код_кнопки == KEY_VOLUMEDOWN and значение == 1:
            текущее_время = time.time()
            
            # Сбрасываем счётчик если прошло больше DOUBLE_CLICK_TIME
            if текущее_время - последнее_нажатие_вниз < DOUBLE_CLICK_TIME:
                счётчик_нажатий_вниз += 1
            else:
                счётчик_нажатий_вниз = 1
            
            последнее_нажатие_вниз = текущее_время
            
            # Двойное нажатие = обновить и показать статистику
            if счётчик_нажатий_вниз == 2:
                безопасный_лог("🔉 Vol DOWN x2: показать статистику")
                print("🔉 Vol DOWN x2 - показываем статистику...")
                
                os.system("clear")
                майнер.отобразить_интерфейс()
                
                счётчик_нажатий_вниз = 0

# ═════════════════════════════════════════════════════════════
# ОСНОВНАЯ ПРОГРАММА
# ═════════════════════════════════════════════════════════════

if __name__ == "__main__":
    безопасный_лог("╔════════════════════════════════════════════╗")
    безопасный_лог("║ NerdMiner V2 запущен (ARM-оптимизированный)║")
    безопасный_лог("╚════════════════════════════════════════════╝")
    
    print("\n┌──────────────────────────────────────────┐")
    print("│ NerdMiner V2 — инициализация...          │")
    print("└──────────────────────────────────────────┘\n")
    
    # Показываем первый экран
    майнер.отобразить_интерфейс()
    
    # Запускаем поток для чтения кнопок
    поток_кнопок = threading.Thread(target=читать_кнопки, daemon=False)
    поток_кнопок.start()
    
    # Запускаем watchdog (дежурный)
    поток_watchdog = threading.Thread(target=дежурный_потокован, daemon=True)
    поток_watchdog.start()
    
    # Основной цикл
    try:
        while RUNNING:
            # Периодически обновляем экран если он включен
            if SCREEN_ON and майнер.майнинг:
                time.sleep(2)
                майнер.отобразить_интерфейс()
            else:
                time.sleep(1)
                
    except KeyboardInterrupt:
        безопасный_лог("\n⌨️ Пользователь нажал Ctrl+C")
        print("\n⌨️ Остановка...")
        RUNNING = False
        майнер.остановить()
        
    print("\n✅ NerdMiner остановлен. До встречи! 👋")
    безопасный_лог("✅ NerdMiner корректно завершил работу")